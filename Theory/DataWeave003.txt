-------------------------------------------------------------------------------------
//What is dataweave & why we have to use it..?
-->
Dataweave is a programming language designed by mulesoft for accessing and transforming
data that travels through mule application.. 
Datawave (dw) format is canonical format (generical format i.e. predefined structure) , for all transformation.. 

//What is the latest version for dataweave..?
-> 2.10.0
we can't write it in header because DataWeave does not support patch/minor version numbers in the header.
---------------------------------------------------------------------------------------------
//List out frequently used dataweave inbuilt functions..?
--> 
We can list out few dataweave functions that we have worked in realtime projects..
map , mapObject , filter, filterObject , flatten , pluck etc..

//How can we invoke or call flows from dataweave..?
--> 
We can use lookup functions but , we can call private flow but not subflow..  
Mule::lookup('privateFlow_Name') 

//How to access property in dataweave..?
--> 
by using P function...  p('http.port')
---------------------------------------------------------------------------------------------
//How to sort an array..?
-->
using orderBy function we can sort array:
To sort in  ascending order: payload orderBy ((item , index)-> item)
To sort in descending order: payload orderBy ((item , index)-> item))[-1 to 0] 

//payload orderBy $ give ascending order value..
//payload orderBy -$ give descending order value..
//(payload orderBy -$)[0] to get the highest value from descending order..
-----------------------------------------------------------------------------------------
//Find smallest and greatest number in an array..?
-->
(payload orderBy((item , index)-> item))[0] <--- for smallest number
(payload orderBy((item , index)-> item))[-1] <--- for greatest number

//Filter out even and odd numbers..?
-->
payload filter ((item , index) -> (item mod 2) == 0) <--- even number
payload filter ((item , index) -> (item mod 2) != 0) <--- Odd number
-------------------------------------------------------------------------------
//How to print current date..?
-->
now() as Date { format: "yyyy-MM-dd" }
now() as Date <-- This outputs only the date part of the current timestamp...
----------------------------------------------------------------------------------
//What is causedBy function in Dataweave..? 
-->
causedBy() is a dataWeave function used inside a try-catch (error handling) block to check whether the
error was thrown by a specific error type..
It works just like checking an error type in a Mule error handler, but inside DataWeave..
error.causedBy("MULE:CONNECTIVITY")

we use it inside a DataWeave try...catch block:
%dw 2.0
output application/json
var result = 
    try 
        payload.a / payload.b
    catch (e) 
        if (e.causedBy("MULE:EXPRESSION")) 
            "Expression Error"
        else 
            "Some other error"
---
result
---------------------------------------
%dw 2.0
output application/json
fun divide(a, b) =
    try 
        a / b
    catch (e) 
        if (e.causedBy("MULE:ZERO_DIVISION")) 
            "Divide by zero detected"
        else 
            "Unknown error"

---
divide(10, 0)

--------------------------------------------------------------------------------------
//Does the desendent(..) selector select all the keys or just first one in nested
 object..?? 
--> 
The descendant selector (..) selects all matching keys at any nested level, not just the first one.
paylod..name  Use payload..name[0] to access only the first match..
-----------------------
//Does the multi value selector(.*) select keys on nested level of the object.. ??
--> 
No , multi value selector doesn't select keys on nested level of the object.
.* only selects immediate child values of an object, not keys nested deeper..
payload.*name

Immediate child = a key/value directly inside the object Not inside another object or array...
-----------------------
//What happens if we combine both Descendent and Multi-value selectors(..*) ??
--> 
..* selects all matching keys at all nested levels, that we want to access..
 payload..*name

//output of multi-value selector is an array(The result of .* is always an array) , it works for both
 array and objects..
------------------------------------------------------------------------------
//How to update value of key..?
-->
import * from dw::util::Values
---
payload map((item , index)-> item update "key" with "value")
-----------------------------------------------------------------------------
//How to convert all keys in object to uppercase..? 
-->
by using upper() from the string as by import * from dw::core::Strings

//How to fetch keys and values of an object..?
--> 
keysOf(payload) ; valuesOf(payload)
----------------------------------------------------------------------------
//How to remove key value pair in JSON object..?
-->
payload -"key1" - "key2"
payload - (["key1", "key2"])
Works only for keys at the same level...
Doesn't delete nested keys (must use other methods for that)...
-------------------------------------------------------------------------------
//How to extract integers only from "a1b2c3d4"..?
-->
%dw 2.0
output application/json
var payload = "a1b2c3d4"
---
flatten(payload scan /\d/) joinBy "" as Number

//How to use splitBy function to "192,88.99.0/24"..?
-->
payload splitBy (/[,.\/]/)

--------------------------------------------------------------------------------
//How to skip null value..?
%dw 2.0 
output application/json skipNullOn="everywhere"
---
payload


%dw 2.0
output application/json skipNullOn="everywhere"
var payload = {
  name: "Bharat",
  age: null,
  skills: ["MuleSoft", null, "Java"],
  details: {
    city: null,
    country: "India"
  }
}
---
payload
---------------------------------------------------------------------------------
//Merge two Arrays and remove duplicates..?
 --> flatten(valuesOf(payload))
 --> flatten(valuesOf(payload)) distinctBy((item , index) -> item)
 --> paylaod reduce ((item , accumulator) -> accumulator ++ item)

 %dw 2.0
output application/json
var payload = {
  a: [1, 2, 3],
  b: [3, 4, 5]
}
---
flatten(valuesOf(payload)) distinctBy $ 

------------------------------------------------------------------------------------------------
//How to swap the key:value pairs..?
-->
payload map (item ->
    item mapObject ((value, key) -> {
        (value as String): key
    })
)

map â†’ loops through each object in the array..
mapObject â†’ loops through the key/value pairs inside each object..
(value as String): key â†’ creates a new key using the original value..
------------------------------------------------------------------------
//What's differene between mapObject & pluck..?
-->
mapObject: The input & output for mapObject function is an object{}..
pluck: The input is object{} & output is an Array[]..
----------------------------------------------------------------------
//Write dataweave script to check if input is prime number..?
--> 
A prime number is a natural number greater than 1 that has no positive divisors other than 1 and 
itself...
%dw 2.0
output application/json
var n = 29
---
n > 1 and not ((2 to (n - 1)) any (i -> n mod i == 0))

--------------------------------------------------------
//How to convert datetime to specific timezone..?
-->
%dw 2.0
output application/json
---
now() >> "PST"

now() >> "Asia/Kolkata"
now() >> "UTC"
now() >> "America/Los_Angeles"
now() >> "Europe/London"
----------------------------------------------------------------
//what is factorial value and how to find it..?
-->
The factorial of a number n (written as n!) means:
ðŸ‘‰ Multiply all whole numbers from n down to 1..
Example:

5! = 5 Ã— 4 Ã— 3 Ã— 2 Ã— 1 = 120

4! = 4 Ã— 3 Ã— 2 Ã— 1 = 24

3! = 3 Ã— 2 Ã— 1 = 6

//Using reduce function:
%dw 2.0
output application/json
var n = 5
---
if (n == 0) 1
else (1 to n) reduce ($$ * $)

//Using a recursive function:
%dw 2.0
output application/json
fun factorial(n) =
    if (n == 0) 1
    else n * factorial(n - 1)
---
factorial(5)

----------------------------------------------------------------------
//How to skip header in csv..?
%dw 2.0
output application/csv header=false
---
payload
------------------------------------------------------------------------------
//How to remove indentation from json output to save memory..?
-->
%dw 2.0
output application/json indent=false
---
paylaod

//What this does:
Removes all pretty formatting..
Produces compact JSON..
Reduces output size (memory + disk)..
---------------------------------------------------------------------------------
//How to print $(doller) in the output..? 
-->
by using \$:

%dw 2.0
output application/json
var price = 99
---
"\$${price}"

%dw 2.0
output application/json
---
"\$100"
-------------------------------------------------------
//How to convert JSON string to JSON..? 
--> 
%dw 2.0
output application/json
var payload = {
  user: "{\"name\":\"Bharat\",\"age\":30}",
  status: "\"active\""
}
---
payload mapObject ((value, key) -> {
  (key): read(value, "application/json")
})
---------------------------------------------------------------------------------
//How many types of targets can created in transform message..?
-->
Three types of targets can created in transform message:
1. payload
2. attributes
3. variable
--------------------------------------------------------------------------------
//How to check if the given string palindrome..?
import * from dw::core::strings
output application/json
---
if(paylaod == reverse(paylaod)) "Palindrome" else "Not a palindrome"
------------------------------------------------------------------------------
//What's differene between == and ~= ?
== will check data & data_types too ---->  5 == 5 , 5 =âŒ= "5"
~= will only check the data  ---->  5 ~= "5" same as 5 ~= 5
-----------------------------------------------------------------------------
//To extract all resulting payloads to an array, use a DataWeave script:
-->
flatten(valuesOf(payload) map ((item, index) -> item.*payload))

%dw 2.0
output application/json
var items = if (payload is Object) valuesOf(payload) else payload
---
flatten(items map (item -> item.payload))
----------------------------------------------------------------------------------------
Difference between flatMap and flatten..?
--> 
flatMap: Iterates over each item in an array and flattens the results, can act on 
values and indices of items in the array.. 
can apply logic to every element
can use value and index
can return arrays, and it will flatten them
It is both iterative + transforming + flattening

Flatten: Turns a nested array into a simple array. only acts on the values of the 
arrays..Turns a set of subarrays[[]] into a single array as output..
No iteration logic
No access to index
Only removes nested arrays
Acts only on values
------------------------------------------------------------------------------------
//DataWeave is the primary data trasformation language for use in Mule flows...
//DataWeave 2.0 is for Mule 4 apps and dataweave 1.0 is for Mule 3 app..
----------------------------------------------------------------------------------
//%dw: Is dataweave version %dw2.0
//import: For importing dataWeave function module...
var: Global variables for defining constants that we can reference throughout the body of the DataWeave script..
fun: For creating custom functions that can be called from within the body of the script..
type: For specifying custom type that we can use as expression...
na: Use to import namespace...
output: Commonly used directive that specifies the mime...
If there is no output then default output is application/java ...
If mime types of the inputs differ , and no output is specified , the script throws an exception so that
we know to specify an output mime type..
-----------------------------------------------------------------------------------------









