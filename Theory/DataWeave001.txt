-----------------------------------------------------------------------------------
// Object is always enclosed with {} and contains key:value pairs..
// An Array is always enclosed with [] and contains only Value(item)..
// Scope are created by using do statement , where we can declare varaibles and more 
function..
-----------------------------------------------------------------------------------------
// function without name called as Lambda , Lambda is value just like string we can assign it to 
varaibles:-  ((argument) -> body) () 
Lambda became useful when we want to use function as argument to other function or 
return function from function which is called higher ordered function..
$ , $$ , $$$ :- 
$ first argument , $$ second argument , $$$ third argument   //(in lambda functions)..
When there is No key  ----> $ represent value $$ represent index..

// prefix function:- In Prefix notation function name came first (before argument 
function name is written) then argument made :- functionName_(argument).
// Infix notation :- In infix notation function takes two argument , Lambda be the 
second argument of it :- (argument_1) functionName_ ->(argument_2)..
-----------------------------------------------------------------------------------
// and operators :- all of the value must be true for output as true if even one value
is false then output print false..

// or operators :- one of the value must be true for output as true if all value is 
false then output print false..

//Metadata :- Is data that provides information about other data , but not the content
of other data...

//index value selector :-  payload[1/-1] -> can have both positive and negative value...
//Range value selector :-  payload[1 to -3] -> can have both positive and negative value...
-----------------------------------------------------------------------------
//Variables are two types pre-defined variables and user defined variables:

//predefined variables: (The scope of variables are application level):
These predefined variables and functions provide a powerful set of tools for performing data transformations
and manipulations within DataWeave...
1. message
2. attributes
3. payload
4. vars
5. error
6. app 
7. flow
8. mule 
9. server

%dw 2.0
output application/json
---
{
"app": app.encoding ,
"flow": flow.name ,
"mule": mule.version ,
"server": server.timeZone 
}

%dw 2.0
output application/json
---
{
	"app": {
		"namespace": app.encoding,
		"applicationName": app.name
	}
}
---------------------------------
//user-defined variables:
These variables will be created by us in our mule flow , their are two types mainly..
1. Flow level variables 
2. Datawave variables..

1. Flow level variables(The scope of variable is flow level) ;
By using transform message component we use flow level varaibles , click on add new target then
assign value for varaibles and save it...

2. Datawave variables(The scope of variable is Datawave level)..
ðŸ§  DataWeave Script Structure
A typical DataWeave script has two main parts:
1. Header Section (Above the --- line)
- This is where we define:
- Global variables
- Functions
- Imports
- Namespaces
- These elements are accessible throughout the entire script â€” both in the header and body..
2. Body Section (Below the --- line)
- This is where we apply the main transformation logic...
- we can define local variables here using var, but their scope is limited to the block or expression they 
are defined in...
--------------------------------------------------------------------------------------------------
//In DataWeave, there are several predefined variables and functions that can use 
to access and manipulate data. Here are some commonly used ones:

1. payload: Represents the main data being processed in a DataWeave transformation.
It's the input data that we want to transform or manipulate...
payload.userName

2. attributes: Contains metadata associated with the input data, such as headers, 
properties, or any other additional information...
attributes.queryParams.Id

3. vars: Allows to declare and store variables within a DataWeave script we ,
can use these variables to store intermediate results or reusable values...
vars.sessionToken

4. vars.correlationId: A variable often used to store a unique identifier that can
be used for correlating messages or tracking transactions...

5. error: Represents an error object that contains information about any errors 
that occur during the transformation process..
error.message

6. server: Provides access to server-related information or configuration 
settings, such as hostname, port number or environment variables.
server.host server.timezone

7. flow: Contains information about the current Mule flow being executed, 
including properties, variables, and metadata associated with the flow.
flow.name

8. message: Represents the entire message being processed, including both the 
payload and any associated metadata or attributes.
message.attributes
message.payload

9. now: Returns the current date and time...
now()as String

10. p(): Shortcut for accessing properties of an object. For example, 
`payload.propertyName` can be abbreviated as `p().propertyName`.

11. sizeOf(): Returns the size or length of a data structure, such as an array 
or object.
sizeOf(payload.items)
-------------------------------------------------------------------------------------
//Types of function allows or provides piece of reusable logic to perform an operation:
Functions: has two types pre-defined functions and user defined functions..

1.Pre-defined functions:
dw::Core 
dw::core::Array
dw::core::Binaries/Dates/Numbers/Objects/Periods/String/Types/URL 
dw::Crypto
dw::extension::DataFormat 

2.User defined function:
Syntax: fun myFunction(param1 , param2, ..) = <code to execute>
Syntax: fun myFunction(param1: Type , param2: Type..):ResultType = <code to execute>..
-------------------------------------------------------------------------------------------
//function syntax :-

fun functionName(param1, param2, param3) = {
  // logic here
}
Whenever there value associate to the first argument , assign value direction  will be right to left..

// function within function called higher order function..

//Q.Define:-
1.Anonymus function: 
function without name, often used inline or passed as an argument..
Use case: Commonly used with map, filter, etc...
[1, 2, 3] map ((x) -> x + 1)
// Output: [2, 3, 4]

2.Lambda function:
A concise anonymous function using arrow syntax ->...In DataWeave, all anonymous functions are lambda functions..

3.higher order function:
A function that takes another function as input or returns a function.. map, filter, reduce are built-in 
higher-order functions..

%dw 2.0 output application/json
fun applyTwice(f, x) = f(f(x))
fun square(n) = n * n
---
applyTwice(square, 2) // Output: 16

%dw 2.0 output application/json
fun applyTwice(f, x) = f(f(x))
fun increment(n) = n + 1
---
applyTwice(increment, 3) // returns 5
-----------------------------------------------------------------------------------
import * from dw::core::Arrays

 //countBy:  
 Groups and counts elements in an array based on a matching condition or key extractor.
return output as object countBy works as boolean (true/false), if it is true it will be print in the output...

//divideBy: 
Splits an array into chunks of a specified size it returns output as form of object of an array..  

//indexOf:
it find first accurance value's index in array and print it...
example: indexOf(var_name , "value")

//slice:
It slice from value to unit value from an array and gives output as (part of) array..
example: slice(var_name , from_index , until_index)..

//sumby: 
it works on array and returns the sum of the values of the elements..
example: []sumBy $.key

//splitAt: 
Splits an array into two at a given pairs...

//dropWhile:
Drops elements from the array while the condition is met but stops the selection process when it reaches an 
element that fails to satisfy the condition...

//join:
Joins two arrays of objects by a same given value criteria...
-----------------------------------------------------------------------------------
// import * from dw::core::Strings

// camelize("hi_mule")  // In input underscore use for camelize
// capitalize("hello mule")  // space added between words for capitalize first letter. output:- "Hello Mule"
//upper("hello") // output:- "HELLO"
//lower("CHIM")  // output:- "chim"
//isUpperCase("hi")  //output :- false (return boolean value)
//isLowerCase("hi")  //output :- true (return boolean value)
//replaceAll(" Hello , CHIM " ,  "CHIM" , "Mule")  // (value  , target , replacement) output:- "Hello , Mule"
//substring("bharat" , 0 , 3) // output :- bha 
//singularize("boys") // output:- boy
//pluralize("girl") // output:- girls
//wrapWith("bharat" , "*") // output:- "*bharat*"

----------------------------------------------------------------------------------
