-------------------------------------------------------------------------------------
//Read function:
read() is used to parse a string or binary data into a structured DataWeave value (object, array, number, etc)..
Use read() when:
The content type cannot be detected automatically..
we have a JSON/XML/CSV string that we want to convert into real structured data..
we want to force a specific content type while parsing..

read(" " , "content-type")
readUrl("classpath://fileName", "file-content-type")
-----------------------------------------------------------------------------------
//Date & Time:

1. Date: 2012-10-11
Creates a Date value from values specified for year, month, and day fields.

2. DateTime:  2012-10-11T10:10:10-03:00
Creates a DateTime value from values specified for year, month, day, hour, minutes, 
seconds, and timezone fields.

3. LocalTime: 10:10:10
Creates a LocalTime value from values specified for hour, minutes, and seconds fields.

4. LocalDateTime: 2012-10-11T10:10:10
LocalDateTime value from values specified for year, month, day, hour, minutes..

5. Time: |05:00|
Creates a Time value from values specified for hour, minutes, seconds, and timezone 
fields...

6. Timezone: |+05:00|

6.1. Timezone: +05:00
This indicates a time offset of 5 hours ahead of UTC...
Example:
2025-11-16T19:00:00+05:00

6.2. DatePeriod: P1Y
P1Y means a period of 1 year...
DatePeriod is used for calendar-based periods (years, months, days)...
Examples:
P1Y → 1 year
P3M → 3 months
P2Y6M5D → 2 years, 6 months, 5 days

6.3. Duration: PT1H
PT1H means a duration of 1 hour...
Duration is used for time-based lengths (hours, minutes, seconds)...
Examples:
PT1H → 1 hour
PT30M → 30 minutes
PT1H20M15S → 1 hour 20 minutes 15 seconds
-------------------------------------------------------------------------------------
//CDATA stands for Character Data:
A CDATA section is used in XML-like markup languages to include text that should not be parsed as markup 
by the XML parser...
---------------------------------------------------------------------------------
//Scan:  
Returns an array with all of the matches found in an input string...

%dw 2.0
output application/json
---
"www.mathoman.com" scan(/([a-z]*)\.([a-z]*)\.([a-z]*)/)
----------------------------------------------------------------------------------
//groupBy:
Returns an object of array {[]} that groups items from an array[] based on specified criteria, such as an 
expression or matching selector...

//zip & unzip:
zip Merges elements from two arrays into an array of arrays[[]] , unzip is opposite of zip..
match:
match {
    case "" -> $
    else -> "  "
}
--------------------------------------------------------------------------------
import * from dw::util::Values

mask:  mask  "keyName" with "******"
The value to use for masking , the value can be any DataWeave type..
-------------------------------------------------------------------------------
//size of:
Returns the number of characters (including white space) in  string. Returns the 
number of elements in an array. It returns 0 if the array is empty. This version of 
sizeOf takes an array[] or an array of arrays[[]] as input...

//then:
This function works as a pipe that passes the value returned from the preceding 
expression to the next (a callback) only if the value returned , by the preceding 
expression is not `null`...
-----------------------------------------------------------------------------------
// import * from dw::util::Coercions

//toString:     toString([" " , " " ])
A variant of toString that joins an Array of characters into a single String value...

// keysOf | namesOf:
Returns an array of strings with the names of all the keys within the given object..
---------------------------------------------------------------------------------
import * from dw::Runtime

Wait: 
Stops the execution for the specified timeout period (in milliseconds)..
WARNING: Stopping the execution blocks the thread, potentially causing slowness, low 
performance and potentially freezing of the entire runtime. This operation is intended 
for limited functional testing purposes. Do not use this function in a production 
application, performance testing , or with multiple applications deployed...
------------------------------------------------------------------------------------
//Explain lookup function..?
-->
lookup() is a DataWeave built-in function used to call a private flow from inside a DataWeave script..
A private flow is an internal flow without an inbound connector, but it can be invoked by the application.
The lookup() function triggers that private flow and returns its output so we can use it in our dataWeave 
transformation...
Subflows cannot be called using lookup() because they are not independent or executable on their own...

%dw 2.0
output application/json
---
Mule::lookup('flow2', {test:'hello '})
--------------------------------------------------------------------------------------